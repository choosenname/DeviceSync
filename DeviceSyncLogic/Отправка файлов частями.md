Для отправки больших файлов, лучше всего разбить файл на меньшие части (chunks) и отправлять их по одному. Вот как это можно сделать:

1. Определите максимальный размер части (chunk) файла. Например, 64 КБ.

2. Разбейте файл на части (chunks) меньше или равные максимальному размеру.

3. Отправьте каждую часть файла с помощью UdpClient.Send().

4. На стороне получателя, соберите все части файла и сохраните его.

Вот пример кода для отправки файла:

```csharp
private async Task SendFileAsync(string filePath)
{
    const int maxChunkSize = 64 * 1024; // 64 KB
    byte[] buffer = new byte[maxChunkSize];

    using (FileStream fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
    {
        int bytesRead;
        while ((bytesRead = await fileStream.ReadAsync(buffer, 0, maxChunkSize)) > 0)
        {
            byte[] chunkToSend = new byte[bytesRead];
            Array.Copy(buffer, chunkToSend, bytesRead);

            FileChunk fileChunk = new FileChunk(PackageType.FileChunk, chunkToSend, Path.GetFileName(filePath));
            string jsonFragment = JsonConvert.SerializeObject(fileChunk);
            byte[] dataToSend = Encoding.UTF8.GetBytes(jsonFragment);

            _udpSender.Connect(Singleton.Instance.IpAddress, Singleton.Instance.RemotePort);
            _udpSender.Send(dataToSend);
        }
    }
}
```

И пример кода для обработки полученных частей файла на стороне получателя:

```csharp
private Dictionary<string, List<FileChunk>> receivedFileChunks = new Dictionary<string, List<FileChunk>>();

private async Task ProcessFileChunkAsync(FileChunk fileChunk)
{
    if (!receivedFileChunks.ContainsKey(fileChunk.FileName))
    {
        receivedFileChunks[fileChunk.FileName] = new List<FileChunk>();
    }

    receivedFileChunks[fileChunk.FileName].Add(fileChunk);

    // Проверьте, все ли части файла получены
    if (AllChunksReceived(fileChunk.FileName))
    {
        // Сохраните файл
        await SaveFileAsync(fileChunk.FileName, receivedFileChunks[fileChunk.FileName]);

        // Удалите информацию о полученных частях файла
        receivedFileChunks.Remove(fileChunk.FileName);
    }
}

private bool AllChunksReceived(string fileName)
{
    // Здесь можно добавить логику для определения того, все ли части файла получены.
    // Например, можно добавить в класс FileChunk свойство TotalChunks и ChunkIndex,
    // чтобы знать общее количество частей и их порядок.
}

private async Task SaveFileAsync(string fileName, List<FileChunk> fileChunks)
{
    string Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), fileNameFileStream fileStream = new FileStream(outputPath, FileMode.Create, FileAccess.Write))
    {
        foreach (FileChunk chunk in fileChunks.OrderBy(fc => fc.ChunkIndex))
        {
            await fileStream.WriteAsync(chunk.Content, 0, chunk.Content.Length);
        }
    }
}
```

Не забудьте вызывать `SendFileAsync` в обработчике кнопки "SendFile_Clicked" и `ProcessFileChunkAsync` в `Receiver` для обработки сообщений типа `PackageType.FileChunk`.